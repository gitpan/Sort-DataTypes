NAME
    Sort::DataTypes - Sort a list of data using methods relevant to the type
    of data

SYNOPSIS
       use Sort::DataTypes qw(:all);

DESCRIPTION
    This allows you to sort a list of data elements using methods that are
    relevant to the type of data it is.

ROUTINES
    sort_valid_method
          use Sort::DataTypes qw(:all)

          $flag = sort_valid_method($string);

        This returns 1 if there is a valid sort method named $string in the
        module. For example:

          sort_valid_method("numerical")
             => 1

          sort_valid_method("foobar")
             => 0

    sort_by_method
          use Sort::DataTypes qw(:all)

          sort_by_method($method,\@list [,@args]);

        This sorts a list using the given method (which is any string which
        returns 1 when passed to sort_valid_method. @args are arguments to
        pass to the sort.

        If the method is not valid, the list is left untouched.

    sort_numerical, sort_rev_numerical, sort_alphabetic, sort_rev_alphabetic
          use Sort::DataTypes qw(:all)

          sort_numerical(\@list);
          sort_rev_numerical(\@list);

        These sorts a list numerically or alphabetically (normal or
        reverse). There's little reason to use these... but are included for
        the sake of completeness.

          sort_numerical(\@list,%hash);
          sort_rev_numerical(\@list,%hash);

        These sort a list based on a hash. Every element in @list has a key
        in %hash, and the values of those keys determine the order of the
        list elements. They are sorted alphabetically or numerically.

    sort_length, sort_rev_length
          use Sort::DataTypes qw(:all)

          sort_length(\@list);
          sort_rev_length(\@list);

          sort_length(\@list,%hash);
          sort_rev_length(\@list,%hash);

        These sorts a list of strings by length.

    sort_ip, sort_rev_ip
          use Sort::DataTypes qw(:all)

          sort_ip(\@list);
          sort_rev_ip(\@list);

          sort_ip(\@list,%hash);
          sort_rev_ip(\@list,%hash);

        These sorts a list A.B.C.D IP numbers.

    sort_domain, sort_rev_domain, sort_numdomain, sort_rev_numdomain
          use Sort::DataTypes qw(:all)

          sort_domain(\@list [,$sep]);
          sort_rev_domain(\@list [,$sep]);

          sort_domain(\@list [,$sep] ,%hash);
          sort_rev_domain(\@list [,$sep] ,%hash);

        This sorts domain names (A.B.C...) or anything else consisting of a
        class, subclass, subsubclass, etc., with the most significant class
        at the right.

        Elements in the domain are separated from each other by a period (.)
        unless $sep is passed in. If $sep is passed in, it is a regular
        expression to split the elements in a domain.

        Since the most significan element in the domain is at the right, any
        domain ending with ".com" would come before any domain ending in
        ".edu".

          a.b < z.b < a.bb < z.bb < a.c

        A related type of sorting is:

          sort_numdomain(\@list [,$sep]);
          sort_rev_numdomain(\@list [,$sep]);

          sort_numdomain(\@list [,$sep] ,%hash);
          sort_rev_numdomain(\@list [,$sep] ,%hash);

        numdomain sorting is identical to domain sorting except that if two
        elements in the domain are integers, numerical sorts will be done.
        So:

          a.11.c < a.2.c

    sort_path, sort_rev_path, sort_numpath, sort_rev_numpath
          use Sort::DataTypes qw(:all)

          sort_path(\@list [,$sep]);
          sort_rev_path(\@list [,$sep]);

          sort_path(\@list [,$sep] ,%hash);
          sort_rev_path(\@list [,$sep] ,%hash);

        This sorts paths (/A/B/C...) or anything else consisting of a class,
        subclass, subsubclass, etc., with the most significant class at the
        left.

        Elements in a path are separated from each other by a slash (/)
        unless $sep is passed in. If $sep is passed in, it is a regular
        expression to split the elements in a path.

        Since the most significan element in the domain is at the left, you
        get the following behavior:

          a/b < a/z < aa/b < aa/z < b/b

        A related type of sorting is:

          sort_numpath(\@list [,$sep]);
          sort_rev_numpath(\@list [,$sep]);

          sort_numpath(\@list [,$sep] ,%hash);
          sort_rev_numpath(\@list [,$sep] ,%hash);

        numpath sorting is identical to path sorting except that if two
        elements in the path are integers, numerical sorts will be done. So:

          a/2/c < a/11/c

    sort_random, sort_rev_random
          use Sort::DataTypes qw(:all)

          sort_random(\@list);
          sort_rev_random(\@list);

          sort_random(\@list,%hash);
          sort_rev_random(\@list,%hash);

        This uses the Fisher-Yates algorithm to randomly shuffle an array in
        place. This routine was taken from the book

          The Perl Cookbook
          Tom Christiansen and Nathan Torkington

        The sort_rev_random is identical, and is included simply for the
        situation where the sort routines are being called in some
        automatically generated code that may add the 'rev_' prefix.

    sort_version, sort_rev_version
          use Sort::DataTypes qw(:all)

          sort_version(\@list);
          sort_rev_version(\@list);

          sort_version(\@list,%hash);
          sort_rev_version(\@list,%hash);

        These sorts a list of version numbers of the form
        MAJOR.MINOR.SUBMINOR ... (any number of levels are allowed). The
        following examples should illustrate the ordering:

          1.1.x < 1.2 < 1.2.x  Numerical versions are compared first at
                               the highest level, then at the next highest,
                               etc. The first non-equal compare sets the
                               order.
          1.a < 1.b            Alphanumeric levels that start with a letter
                               are compared alphabetically.
          1.2a < 1.2 < 1.03a   Alphanumeric levels that start with a number
                               are first compared numerically with only the
                               numeric part. If they are equal, alphanumeric
                               levels come before purely numerical levels.
                               Otherwise, they are compared alphabetically.
          1.a < 1.2a           An alphanumeric level that starts with a letter
                               comes before one that starts with a number.
          1.01a < 1.1a         Two alphanumeric levels that are numerically
                               equal in the number part and equal in the
                               remaining part are compared alphabetically.

    sort_date, sort_rev_date
          use Sort::DataTypes qw(:all)

          sort_date(\@list);
          sort_rev_date(\@list);

          sort_date(\@list,%hash);
          sort_rev_date(\@list,%hash);

        These sorts a list of dates. Dates are anything that can be parsed
        with Date::Manip.

    sort_line, sort_rev_line, sort_numline, sort_rev_numline
          use Sort::DataTypes qw(:all)

          sort_line(\@list,$n [,$sep]);
          sort_rev_line(\@list,$n [,$sep]);

          sort_line(\@list,$n [,$sep] ,%hash);
          sort_rev_line(\@list,$n [,$sep] ,%hash);

        These take a list of lines and sort on the Nth field using $sep as
        the regular expression splitting the lines into fields. If no $sep
        is given, it defaults to white space.

          sort_numline(\@list,$n [,$sep]);
          sort_rev_numline(\@list,$n [,$sep]);

          sort_numline(\@list,$n [,$sep] ,%hash);
          sort_rev_numline(\@list,$n [,$sep] ,%hash);

        These are similar but will sort numerically if the Nth field is an
        integer, and alphabetically otherwise.

KNOWN PROBLEMS
    None at this point.

AUTHOR
    Sullivan Beck (sbeck@cpan.org)

